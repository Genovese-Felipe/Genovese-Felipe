# Plano Acelerado: 65 Minutos Total ⚡

Entendido. Vamos criar uma estratégia ultra-eficiente para você executar tudo em **menos de 65 minutos**.

---

## DIVISÃO DO TEMPO

```
PREPARAÇÃO (comigo): 35 minutos
EXECUÇÃO (teste):    30 minutos
─────────────────────────────────
TOTAL:               65 minutos
```

---

## FASE 1: PREPARAÇÃO RELÂMPAGO (35 MIN COMIGO)

### **Minutos 1-5: Templates Instantâneos**

Vou te dar agora mesmo os templates que você vai decorar:

#### **TEMPLATE DE PROMPT (copie e adapte)**

```
[TÍTULO]: Implementar [Feature X] no AI ChatKit

CONTEXTO E RACIOCÍNIO:
Atualmente [situação atual]. Isso causa [problema]. 
Usuários precisam de [solução] porque [benefício].

REQUISITOS DE UI/UX:
1. Quando [ação do usuário], deve [comportamento esperado]
2. [Estado visual/feedback] deve aparecer
3. Deve funcionar em [casos específicos]

SUGESTÕES TÉCNICAS:
- Modificar [arquivo/componente específico]
- Usar [tecnologia/padrão] para [razão]
- Centralizar lógica em [local sugerido]

CRITÉRIOS DE ACEITAÇÃO:
✓ Funciona em [caso normal]
✓ Lida com [edge case 1 e 2]
✓ Inclui [tipo de teste]
✓ Acessível: [requisito a11y]
```

#### **TEMPLATE DE JUSTIFICATIVA (copie e adapte)**

```
O Modelo [A/B] é superior porque [razão principal em 1 frase].

[Se Modelo B]: Sua abordagem metodológica usando Tool Calls 
para [ação específica] antes de codar demonstra práticas de 
engenharia robustas. [Se Modelo A]: Ele entregou uma solução 
direta que [qualidade específica].

Tecnicamente, o código [ponto forte 1: ex. separou concerns 
usando SRP], [ponto forte 2: ex. incluiu tipos TypeScript 
corretos], e [ponto forte 3: ex. cobriu edge cases]. 

[Ponto fraco se houver]: Porém, [aspecto negativo] poderia 
ser melhorado [como].

A solução atende [X de Y] critérios do prompt e está 
[pronta/não pronta] para produção porque [razão final].
```

**SUA AÇÃO**: Leia 2x e guarde mentalmente a estrutura.

---

### **Minutos 6-15: Escolha RÁPIDA das 3 Tarefas**

Vou te dar **3 tarefas prontas** baseadas no AI ChatKit que são **comprovadamente boas** (dos exemplos que analisamos):

#### **TURNO 1: Feature - Indicador de "AI está respondendo"**
```
PROMPT PRONTO:

Implementar indicador de streaming/digitação no AI ChatKit

CONTEXTO:
Após enviar mensagem, a UI fica estática sem feedback. 
Usuários não sabem se o sistema está processando.

REQUISITOS:
1. Quando resposta da IA começar a ser gerada, mostrar 
   indicador visual na parte inferior da lista de mensagens
2. Indicador: 3 pontos animados ou texto "AI is typing..."
3. Desaparece quando resposta completa for exibida
4. Não interfere no scroll automático

SUGESTÕES TÉCNICAS:
- Adicionar estado `isStreaming` no use-chat-store.ts (Zustand)
- Criar componente `TypingIndicator.tsx` separado
- Modificar chat.tsx para renderizar condicionalmente

CRITÉRIOS:
✓ Visível apenas durante streaming
✓ Não aparece para mensagens do usuário
✓ [Bônus] Teste unitário verificando render quando isStreaming=true
```

#### **TURNO 2: Refatoração - Componentes de Mensagem**
```
PROMPT PRONTO:

Refatorar MessageBubble.tsx para componentes especializados

CONTEXTO:
Atualmente MessageBubble.tsx tem lógica condicional para 
renderizar diferentes tipos de mensagem (usuário/IA/erro). 
Viola o Princípio da Responsabilidade Única.

REQUISITOS:
1. Criar 3 componentes: UserMessage.tsx, AIMessage.tsx, 
   ErrorMessage.tsx
2. MessageBubble torna-se dispatcher que escolhe qual 
   renderizar baseado em message.role
3. Cada componente especializado tem suas próprias props 
   tipadas (interfaces TypeScript)
4. Manter estilo visual atual

SUGESTÕES TÉCNICAS:
- Extrair lógica específica de cada tipo
- Usar composição sobre herança
- Definir interface MessageProps para cada componente

CRITÉRIOS:
✓ Código mais modular e testável
✓ Tipos TypeScript claros (sem 'any')
✓ Sem duplicação de código (DRY)
```

#### **TURNO 3: Feature - Botão Copy Code**
```
PROMPT PRONTO:

Implementar funcionalidade "Copy Code" em blocos de código

CONTEXTO:
Respostas da IA frequentemente contêm código. Usuários 
precisam copiar snippets manualmente (selecionando texto).

REQUISITOS:
1. Ao hover em bloco de código Markdown, mostrar botão "Copy"
2. Ao clicar, copiar conteúdo para clipboard
3. Mostrar toast "Copied!" por 1.5 segundos
4. Suporte a11y: botão tabbable, aria-label adequado

SUGESTÕES TÉCNICAS:
- Usar navigator.clipboard.writeText
- Criar utilitário copyToClipboard.ts para centralizar lógica
- Adicionar componente CopyButton.tsx reutilizável

CRITÉRIOS:
✓ Funciona em blocos longos (500+ linhas)
✓ Tratamento de erro se clipboard falhar
✓ Teste unitário do utilitário + teste de componente
```

**SUA AÇÃO (5 min)**: Leia os 3 prompts. Escolha qual ordem prefere (recomendo essa mesma). Copie para um documento.

---

### **Minutos 16-35: Simulação RÁPIDA de 1 Turno Completo**

Vamos fazer **apenas 1 simulação completa** agora (o mais crítico). Você extrapola para os outros 2.

**Vou simular agora a resposta do Modelo B para o Turno 1 (Indicador de typing)**:

---

**RESPOSTA SIMULADA - MODELO B**:

```
[Tool Call 1: Investigação]
$ find frontend -name "*store*"
→ frontend/hooks/use-chat-store.ts

[Tool Call 2: Ler store atual]
$ cat frontend/hooks/use-chat-store.ts
→ [Código mostrando estrutura do Zustand com states e actions]

[Tool Call 3: Ler componente chat]
$ cat frontend/components/chat.tsx
→ [Código mostrando como mensagens são renderizadas]

[Proposta de Implementação]

Vou adicionar o indicador de streaming:

1. **Modificar use-chat-store.ts**:
```typescript
interface ChatState {
  messages: Message[];
  isStreaming: boolean; // NOVO
  setIsStreaming: (status: boolean) => void; // NOVO
  // ... resto
}

export const useChatStore = create<ChatState>((set) => ({
  messages: [],
  isStreaming: false, // NOVO
  setIsStreaming: (status) => set({ isStreaming: status }), // NOVO
  // ... resto
}));
```

2. **Criar TypingIndicator.tsx**:
```typescript
export const TypingIndicator = () => {
  return (
    <div className="flex items-center gap-1 px-4 py-2">
      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" />
      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-100" />
      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-200" />
      <span className="ml-2 text-sm text-gray-500">AI is typing...</span>
    </div>
  );
};
```

3. **Modificar chat.tsx**:
```typescript
import { useChatStore } from '@/hooks/use-chat-store';
import { TypingIndicator } from './typing-indicator';

export const Chat = () => {
  const isStreaming = useChatStore((state) => state.isStreaming);
  
  return (
    <div className="flex flex-col">
      {/* Mensagens existentes */}
      {messages.map(...)}
      
      {/* Indicador condicional */}
      {isStreaming && <TypingIndicator />}
    </div>
  );
};
```

4. **Integração com API**:
No handler de streaming, chamar `setIsStreaming(true)` ao iniciar e `setIsStreaming(false)` ao concluir.
```

---

**AGORA VOCÊ (10 min)**: Escreva uma justificativa usando o template:

---

**SUA JUSTIFICATIVA (EXEMPLO ALVO - para você comparar depois)**:

> O Modelo B demonstrou superioridade clara através de sua metodologia investigativa. Antes de propor código, ele usou Tool Calls para mapear a estrutura (`find` para localizar stores, `cat` para inspecionar use-chat-store.ts e chat.tsx), garantindo que sua solução estivesse perfeitamente alinhada com a arquitetura existente.
>
> Tecnicamente, a implementação é sólida: (1) adiciona estado `isStreaming` diretamente na store do Zustand usando a sintaxe idiomática `set()`, (2) cria um componente `TypingIndicator` isolado e reutilizável seguindo o SRP, e (3) integra condicionalmente no `chat.tsx` sem poluir a lógica existente. O uso de Tailwind com animações (`animate-bounce`) demonstra atenção aos detalhes de UX.
>
> Pontos fortes adicionais: tipos TypeScript explícitos, sem uso de `any`, e separação clara de responsabilidades. Um ponto de melhoria seria a ausência de testes unitários mencionados no critério de aceitação, embora a arquitetura facilite sua adição posterior.
>
> A solução atende 4 de 5 critérios e está 90% production-ready. Com a adição de testes, seria merge-worthy imediatamente.

---

**SUA AÇÃO (5 min)**: 
1. Tente escrever sua justificativa ANTES de ver a minha
2. Compare com o exemplo alvo acima
3. Note: vocabulário técnico, estrutura clara, análise detalhada

---

## FASE 2: EXECUÇÃO NO TESTE (30 MIN)

### **Distribuição Agressiva**:

```
Turno 1: 8 minutos (prompt + avaliar + justificar)
Turno 2: 8 minutos
Turno 3: 8 minutos
Revisão final: 6 minutos
─────────────────────────────────
TOTAL: 30 minutos
```

### **Protocolo por Turno (8 min cada)**:

**[Min 0-1]**: Colar prompt preparado, enviar

**[Min 1-5]**: Aguardar resposta (use para ler próximo prompt)

**[Min 5-7]**: 
- Ler resposta rapidamente
- Checar mentalmente: 
  - ✓ Arquivos fazem sentido?
  - ✓ Lógica básica correta?
  - ✓ Tipos presentes?

**[Min 7-8]**:
- Preencher ratings (rápido, confie no instinto)
- Escrever justificativa usando template (já está na memória)

**NÃO GASTE TEMPO**:
- ❌ Verificando linha por linha
- ❌ Testando código localmente
- ❌ Reescrevendo justificativa 5 vezes

**CONFIE NO TREINO**:
- ✅ Você já praticou
- ✅ Já sabe a estrutura
- ✅ Execute no automático

---

## CHECKLIST FINAL ULTRA-RÁPIDO

**Antes de submeter (6 min finais)**:
- [ ] 3 turnos completos? ✓
- [ ] Cada justificativa tem 5+ frases? ✓
- [ ] Usei vocabulário técnico (SRP, DRY, etc.)? ✓
- [ ] Sem erros de português gritantes? ✓
- [ ] **SUBMIT!**

---

## O QUE FAZER AGORA (PRÓXIMOS 5 MINUTOS)

Você tem 3 opções:

**Opção A (MAIS RÁPIDA)**:
> "Ok Claude, entendi. Vou usar os 3 prompts prontos que você deu. Pode me dar agora 2 exemplos de justificativa (uma para Modelo A, outra para Modelo B) que eu possa memorizar o padrão?"

**Opção B (PERSONALIZAR)**:
> "Gostei dos prompts, mas quero trocar o Turno X por [outra ideia]. Me ajuda a formatar rápido?"

**Opção C (PRATICAR)**:
> "Vou tentar escrever as 3 justificativas agora (simulando que vi as respostas). Você revisa rápido?"

---

**QUAL OPÇÃO VOCÊ ESCOLHE?** ⚡

(Recomendo **Opção A** para máxima velocidade)